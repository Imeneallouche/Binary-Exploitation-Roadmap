# 64-bit Stack-based Buffer Overflow

The purpose of this lab is to understand how to get control of the RIP register when dealing with classic stack-based buffer overflow vulnerabilities in 64-bit Linux programs.
This lab is based on a <a href="https://blog.techorganic.com/2015/04/10/64-bit-linux-stack-smashing-tutorial-part-1/">great post</a>

```yaml
NOTE: that the vulnerable program used in this lab was compiled without memory protections deliberately and similarly, the ASLR was disabled.
```

<br>

# Vulnerable Code
In this lab, we will be using the below vulnerable program, which declares a buffer buf of 80 bytes, but then allows writing 400 bytes to it, which when done, will overwrite stack's contents, specifically, the RBP and the return address, which can and will be exploited in this lab:

```c
// code from https://blog.techorganic.com/2015/04/10/64-bit-linux-stack-smashing-tutorial-part-1/

#include <stdio.h>
#include <unistd.h>

int vuln() {
    char buf[80];
    int r;
    r = read(0, buf, 400);
    printf("\nRead %d bytes. buf is %s\n", r, buf);
    puts("No shell for you :(");
    return 0;
}

int main(int argc, char *argv[]) {
    printf("Try to exec /bin/sh");
    vuln();
    return 0;
}
```

```yaml
Remember about the stack
- Stack grows downwards
- Local variables are defined at lower stack addresses
- Return address is located higher up in the stack, compared to local variables
```

We can compile the above code with:

```bash
gcc -fno-stack-protector -z execstack vulnerable.c -o vulnerable
```

Don't forget to disable the ASLR:

```bash
echo 0 > /proc/sys/kernel/randomize_va_space
```

<br>

# Getting Control of RIP
Let's try to overflow the program's buf buffer by sending some garbage data to it. First of, let's generate the said garbage data - 200 AAAAs:

```bash
python -c "print 'A'*200" > in.bin
```

Let's now run the vulnerable program, feed the garbage file to it and observe the program crash:

```bash
gdb vulnerable
r < in.bin
```

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/28e1ece5-8080-4483-9195-00ebf9cbc692)

Note from the above screenshot the following key points:

- The stack has been overflowed with As (lime);
- RIP register (red) has not been overflowed although it would have been, had this been a 32-bit binary. On the same note, we can indeed see that the return address (RSP + 0 as ret instruction would pop this value and jump to it) has been filled with AAAA...s, so why are we not in control of the RIP register?
