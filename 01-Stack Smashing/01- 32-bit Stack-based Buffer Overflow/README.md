# 32-bit Stack-based Buffer Overflow

This is a quick lab to capture a high level process of how to exploit a primitive stack-based buffer overlow vulnerability. This lab is based on an intentionally vulnerable 32-bit Windows program provided by security tube.

# Overview
<h2> Vulnerability </h2>
At a high level, exploiting a buffer overflow boils down to the following key points:

```yaml
- Attacker overflows vulnerable program's memory buffer by writing to it more data (including the malicious code, usually shellcode) than the program anticipated, but did nothing (bound checking) to prevent it from happening;

- When a memory buffer is overflowed, the adjacent memory in the vulnerable program is replaced with malicious content supplied by an attacker;

- Attacker subverts the vulnerable program and forces it to execute the malicious code, which was written to the compromised program's memory, when the program's memory buffer was overflowed;
  
- The vulnerable program starts executing malicious code, and depending on what the vulnerable program is/what security context it runs in and whether it is being exploited locally or over the network, results in attacker escalating their privileges on an already compromised system or provides them with a remote access to system being exploited.
```

# Lab
In this lab, we're going to exploit the vulnerable program and make it execute our shellcode by following the below process:
```yaml
- Send some data to the vulnerable program and observe it crash;

- Inspect the program's registers at the time of the crash, focusing on EIP and ESP;

- Send some more data to the vulnerable program, observe it crash and inspect the registers;

- Determine if we can take control of / overwrite the EIP register;

- Determine how much data we need to send to the vulnerable program, before we can overflow its stack and get control of the EIP;

- Determine where our shellcode is written to, which as we will see soon, is pointed to by the ESP;

- Find a memory address that contains the instruction jmp esp, so that we can point the EIP to this address, so that the vulnerable program transfers control to our shellcode (pointed to by the ESP) when the exploit is triggered;

- Overflow the vulnerable program's stack with a buffer larger than it expected. The buffer will be crafted in such a way, that once in the vulnerable program's memory, it will have:

{
 - Written our shellcode;
 - Overwritten the function's return address in the stack with a memory address that contains the  jmp esp instruction, which will force the vulnerable program to jump to our schellcode, once it tries to return after processing our supplied ovesized buffer;
}

Profit - receive a reverse shell from the vulnerable server.
```


Visually, a simplified diagram of the stack overflow vulnerability that we will exploit / vulnerable program's memory layout before and after the overflow would look something like this:

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/5397c799-9db9-4999-b0fd-77295b0aac2a)

# Observing the crash:

always observe the value that is stored in EIP and the ESP (EIP for the next instruction and the ESP to see if we overflowed the stack)

```bash
"hello" | nc 192.168.99.3 10000
```
```bash
python -c "print('A'*200)" | nc 192.168.99.3 10000
```

# Finding EIP offset:

by using the **pwntools library** you can generate a pattern

```python
from pwn import *
pattern = cyclic(300)
```

send that pattern to the vuln program:

```bash
python -c "print(cyclic(300))" |  nc 192.168.99.3 10000
```
we will ssee that:
```yaml
- EIP points to 6A413969: which is part of the string pattern we submitted to the vulnerable program;
- ESP points to 0060FB20: which is indeed the memory address that we should place our shellcode.
```

This means that we will need to ensure that we overwrite the function's return address (the address it wants to return to when it finishes processing our oversized malicious buffer) with a memory address that contains the jmp esp instruction (we will find it next), which when executed, would make the program jump to our shellcode (because it's pointed to by the ESP) and execute it.

Now we have all the information we need in order to find the actual number of bytes we need to send to the vulnerable program, before we can overwrite the EIP and make it point to the 0060FB20 (ESP), as we've just learned above. 

```python
from pwn import *



