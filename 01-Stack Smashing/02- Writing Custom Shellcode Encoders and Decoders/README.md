# Writing Custom Shellcode Encoders and Decoders

The purpose of this lab is to get a bit more comfortable with writing primitive custom shellcode encoders and decoders.
Shellcode encoding simply means transforming original shellcode bytes into a set of arbitrary bytes by following some rules (encoding scheme), that can be later be reverted back to their original values by following the same rules (decoding scheme) in reverse.
```yaml
NOTE: Shellcode encoding may be useful in evading static antivirus signatures and eliminating null bytes.
```

<br>

# Encoder

<h2>Raw Shellcode</h2>
To make it simple, for this lab, let's imagine that our raw shellcode (before encoding) is made of the following bytes:

```py
$shellcode = 0x6F,0x72,0x69,0x67,0x69,0x6E,0x61,0x6C,0x20,0x73,0x68,0x65,0x6C,0x6C,0x63,0x6F,0x64,0x65
```

..which is actually just a simple string original shellcode as you can see here:

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/b307e4a1-afe8-414c-ba69-c3e2a4d86579)

<br>

<h2>Encoding Scheme</h2>
Now that we have the raw shellcode bytes, we need to decide on the algorithm that defines how each byte of the raw shellcode should be encoded/transformed. There's many ways to do it, but for this lab, let's define our encoding steps like this:

```yaml
- xor with 0x55
- increment by 1
- xor with 0x11
```

<br>

<h2>The Encoder Itself</h2>

Let's write a simple powershell script that will help us cycle through the raw shellcode bytes and encode them by performing operations defined in our encoding scheme:

```bash
<#
    Encoding steps:
    1. xor with 0x55
    2. increment by 1
    3. xor with 0x11
#>

# Original raw shellcode bytes
$shellcode = 0x6F,0x72,0x69,0x67,0x69,0x6E,0x61,0x6C,0x20,0x73,0x68,0x65,0x6C,0x6C,0x63,0x6F,0x64,0x65
$printFriendly = ($shellcode | ForEach-Object ToString x2) -join ',0x'
write-host "Original shellcode: 0x$printFriendly"

# Iterate through shellcode bytes and encode them
$encodedShellcode = $shellcode | % {
    $_ = $_ -bxor 0x55
    $_ = $_ + 0x1
    $_ = $_ -bxor 0x11
    Write-Output $_
}

# Print encoded shellcode
$printFriendly = ($encodedShellcode | ForEach-Object ToString x2) -join ',0x'
write-host "Encoded shellcode: 0x$printFriendly"

# Print encoded bytes size
write-host "Size: " ('0x{0:x}' -f $shellcode.count)

# Check if encoded shellcode contains null bytes
write-host "Contains NULL-bytes:" $encodedShellcode.contains(0)
```

If we run the encoder on our shellcode bytes 
```yaml
0x6F,0x72,0x69,0x67,0x69,0x6E,0x61,0x6C,0x20,0x73,0x68,0x65,0x6C,0x6C,0x63,0x6F,0x64,0x65
```
 it will spit out the encoded shellcode bytes (lime) and show if null bytes were found (lime):

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/2d6034a9-69cd-4e66-87d9-1508eaffbf03)

Note that it also shows the shellcode size (orange) - we will need it later when writing a decoder, so that we can tell the decoder how many shellcode bytes it should process.



<br><br><br>

# Decoder

<h2>Decoding Scheme</h2>

The decoding scheme is the same as the encoding scheme, only in reverse:

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/f1c40d0a-daee-429a-bd2f-cdecbcb65027)

