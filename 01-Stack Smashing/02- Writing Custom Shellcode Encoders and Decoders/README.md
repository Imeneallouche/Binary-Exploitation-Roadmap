# Writing Custom Shellcode Encoders and Decoders

The purpose of this lab is to get a bit more comfortable with writing primitive custom shellcode encoders and decoders.
Shellcode encoding simply means transforming original shellcode bytes into a set of arbitrary bytes by following some rules (encoding scheme), that can be later be reverted back to their original values by following the same rules (decoding scheme) in reverse.
```yaml
NOTE: Shellcode encoding may be useful in evading static antivirus signatures and eliminating null bytes.
```

<br>

# Encoder

<h2>Raw Shellcode</h2>
To make it simple, for this lab, let's imagine that our raw shellcode (before encoding) is made of the following bytes:

```py
$shellcode = 0x6F,0x72,0x69,0x67,0x69,0x6E,0x61,0x6C,0x20,0x73,0x68,0x65,0x6C,0x6C,0x63,0x6F,0x64,0x65
```

..which is actually just a simple string original shellcode as you can see here:

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/b307e4a1-afe8-414c-ba69-c3e2a4d86579)

<br>

<h2>Encoding Scheme</h2>
Now that we have the raw shellcode bytes, we need to decide on the algorithm that defines how each byte of the raw shellcode should be encoded/transformed. There's many ways to do it, but for this lab, let's define our encoding steps like this:

```yaml
- xor with 0x55
- increment by 1
- xor with 0x11
```

<br>

<h2>The Encoder Itself</h2>

Let's write a simple powershell script that will help us cycle through the raw shellcode bytes and encode them by performing operations defined in our encoding scheme:

```bash
<#
    Encoding steps:
    1. xor with 0x55
    2. increment by 1
    3. xor with 0x11
#>

# Original raw shellcode bytes
$shellcode = 0x6F,0x72,0x69,0x67,0x69,0x6E,0x61,0x6C,0x20,0x73,0x68,0x65,0x6C,0x6C,0x63,0x6F,0x64,0x65
$printFriendly = ($shellcode | ForEach-Object ToString x2) -join ',0x'
write-host "Original shellcode: 0x$printFriendly"

# Iterate through shellcode bytes and encode them
$encodedShellcode = $shellcode | % {
    $_ = $_ -bxor 0x55
    $_ = $_ + 0x1
    $_ = $_ -bxor 0x11
    Write-Output $_
}

# Print encoded shellcode
$printFriendly = ($encodedShellcode | ForEach-Object ToString x2) -join ',0x'
write-host "Encoded shellcode: 0x$printFriendly"

# Print encoded bytes size
write-host "Size: " ('0x{0:x}' -f $shellcode.count)

# Check if encoded shellcode contains null bytes
write-host "Contains NULL-bytes:" $encodedShellcode.contains(0)
```

If we run the encoder on our shellcode bytes 
```yaml
0x6F,0x72,0x69,0x67,0x69,0x6E,0x61,0x6C,0x20,0x73,0x68,0x65,0x6C,0x6C,0x63,0x6F,0x64,0x65
```
 it will spit out the encoded shellcode bytes (lime) and show if null bytes were found (lime):

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/2d6034a9-69cd-4e66-87d9-1508eaffbf03)

Note that it also shows the shellcode size (orange) - we will need it later when writing a decoder, so that we can tell the decoder how many shellcode bytes it should process.



<br><br><br>

# Decoder

<h2>Decoding Scheme</h2>

The decoding scheme is the same as the encoding scheme, only in reverse:

![image](https://github.com/Imeneallouche/Binary-Exploitation-Roadmap/assets/89279264/f1c40d0a-daee-429a-bd2f-cdecbcb65027)

which means that we will have to iterate through all the encoded bytes of the shellcode and transform them into original bytes like this:

```yaml
- xor with 0x11
- decrement by 0x1 (because we incremented when encoding, we need to decrement now)
- xor with 0x55
```

A fully commented NASM **decoder.asm** is here:

```asm
global _start

section .text
    _start:
        jmp short shellcode

    decoder:
        pop rax                 ; store encodedShellcode address in rax - this is the address that we will jump to once all the bytes in the encodedShellcode have been decoded

    setup:
        xor rcx, rcx            ; reset rcx to 0, will use this as a loop counter
        mov rdx, 0x12           ; shellcode size is 18 bytes

    decoderStub:
        cmp rcx, rdx            ; check if we've iterated and decoded all the encoded bytes
        je encodedShellcode     ; jump to the encodedShellcode, which actually now contains the decoded shellcode
        
        ; encodedShellcode bytes are being decoded here per our decoding scheme
        xor byte [rax], 0x11    ; 1. xor byte with 0x11
        dec byte [rax]          ; 2. decremenet byte by 1
        xor byte [rax], 0x55    ; 3. xor byte with 0x55
        
        inc rax                 ; point rax to the next encoded byte in encodedShellcode
        inc rcx                 ; increase loop counter
        jmp short decoderStub   ; repeat decoding procedure
            
    shellcode:
        call decoder            ; jump to decoder label. This pushes the address of encodedShellcode to the stack (to be popped into rax as the first instruction under the decoder label)
        encodedShellcode: db 0x2a,0x39,0x2c,0x22,0x2c,0x2d,0x24,0x2b,0x67,0x36,0x2f,0x20,0x2b,0x2b,0x26,0x2a,0x23,0x20
```
